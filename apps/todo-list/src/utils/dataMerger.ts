/**
 * Given sets of winning projects, returning them updated with conflicts merged.
 *
 * For each item, `hasConflict = true` will be set if it does have conflicts.
 *
 * @param db the target db
 * @param projects winning docs of projects
 * @returns updated `projects` with fields merged accordingly. See `story.md`.
 */
export async function fetchConflictingProjectsAndShowMergedResult(
  db: PouchDB.Database,
  projects: Doc<Project>[]
) {
  const ids: string[] = projects.map((proj) => proj._id);
  const conflicts = (await db.allDocs<Doc<Project>>({
    include_docs: true,
    keys: ids,
    conflicts: true
  })).rows;

  const promises: Promise<Doc<Project>>[] = [];
  for (const c of conflicts) {
    if ('doc' in c && c.doc) {
      const revs = c.doc._conflicts ?? [];
      const id = c.doc._id;
      revs.forEach((rev) => {
        promises.push(db.get(id, { rev }));
      });
    }
  }

  const docs = await Promise.all(promises);

  // update in-place
  const dict = makeDict(projects, (proj) => proj._id);
  for (const d of docs) {
    const found = dict[d._id];
    if (found) {
      // different sprint_ids will be appended
      // different participant will be added
      // same participant with different roles will be appended
      found.hasConflict = true;
      mergeStringList(found.sprint_ids, d.sprint_ids);
      mergeParticipants(found.participants, d.participants);
    }
  }

  return projects;
}

/**
 * Given an array, return an object with keys generated by fn and values the item itself.
 *
 * Good to be used to make an index to an array, so updates could accelerate.
 *
 * @param arr the array as input
 * @param fn how to get the key
 * @returns an object with `fn(item) -> item`
 */
export function makeDict<T>(
  arr: T[],
  fn: (item: T) => string
): Record<string, T> {
  const result: Record<string, T> = {};
  for (const item of arr) {
    const key = fn(item);
    result[key] = item;
  }

  return result;
}

function mergeStringList(original: string[], incoming: string[]) {
  const cache = new Set<string>(original);
  for (const item of incoming) {
    if (!cache.has(item)) {
      cache.add(item);
      original.push(item);
    }
  }
}

function mergeParticipants(
  original: Project['participants'],
  incoming: Project['participants']
) {
  for (const key in incoming) {
    if (key in original) {
      mergeStringList(original[key], incoming[key]);
    } else {
      original[key] = incoming[key];
    }
  }
}
